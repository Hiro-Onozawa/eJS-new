// externC とあれば，ここに書かれている型を100%信用する．
// externC がなければ，どこかに書かれている定義とここに書かれている型を
// 照合する．

// 便宜的に C の関数は "大文字" で始めることとする

externC (needContext, triggerGC)
FixnumToString : Fixnum -> String

externC (needContext, triggerGC)
FlonumToString : Flonum -> String

externC (needContext, triggerGC)
SpecialToString : Special -> String

externC (needContext, triggerGC)          // ObjectToString は DSL で書かない?
ObjectToString : JSObject -> String

externC
FixnumToCint : Fixnum -> cint

externC
FixnumToCdouble : Fixnum -> cdouble

externC
FlonumToCint : Flonum -> cint

externC
FlonumToCdouble : Flonum -> cdouble

externC (needContext, triggerGC)
CintToNumber : cint -> Number

externC (needContext, triggerGC)
CdoubleToNumber : cdouble -> Number

externC (needContext, triggerGC)
CintToFixnum : cint -> Fixnum

externC
CintToCdouble : cint -> cdouble    // キャスト（関数を呼び出すわけではない）

externC (needContext, triggerGC)
StringToNumber : String -> Number       // StringToNumber は DSL で書かない?

externC (needContext, triggerGC)
SpecialToNumber : Special -> Number     // SpecialToNumber は DSL で書かない?

externC (needContext, triggerGC)          // ObjectToNumber は DSL で書かない?
ObjectToNumber : JSObject -> Number

externC (needContext)
Special_to_object : Special -> JSObject

externC
StringToBoolean : String -> Bool       // C のコードで is_string したくない

externC
Special_to_boolean : Special -> Bool

externC (needContext, triggerGC)
Concat : (String, String) -> String

externC
Isinf : cdouble -> cint

externC
Isnan : cdouble -> cint

externC
Is_object : JSValue -> cint

externC
Is_undefined : JSValue -> cint

externC
Strcmp : (Top, Top) -> cint

externC
String_to_cstr : JSValue -> Top

externC (needContext)
Get_opcode : () -> cint

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
Call_function : (Function, cint, cint) -> void

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
Call_builtin : (Function, cint, cint, cint) -> void

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
Tailcall_function : (Function, cint, cint) -> void

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
Tailcall_buildin : (Function, cint, cint, cint) -> void

externC (needContext)
ObjectToPrimitive : (JSValue, cint) -> JSValue
         // Object_to_primitive は第二引数で toString => valueOf にするか
         // valueOf => toString にするか指定する．これが DSL 上にあってもよいか


externC (needContext)
Geta : () -> JSValue

externC
Fframe_prev : HeapObject -> HeapObject

externC
Fframe_arguments : HeapObject -> JSObject

//externC (needContext, changeContext)
externC (needContext)
Get_err : () -> JSValue

externC (needContext)
Get_prop_global : JSValue -> JSValue
// 現状の get_prop は context->global を第一引数で呼び出し，そのプロパティがなければ FAIL を返す．
// SUCCESS だったときには第三引数に結果の JSValue が返ってくる．エラー処理のため．新バージョンではどうするか．

//externC (needContext, changeContext)
externC (needContext)
Set_prop_global : (JSValue, JSValue) -> cint
// 現状の set_prop_none は context->global を第二引数で呼び出し，そのプロパティがなければ FAIL を返す．
// context->global ができないので，それをやる専用の C 関数とする


externC (needContext)
Get_prop : JSValue -> JSValue
// Get_prop_global と同様

externC (needContext)
Get_next_propname_simple_iterator : JSValue -> JSValue
// Get_prop_global と同様

externC (needContext)
Get_globalobj : () -> JSValue

externC
Fframe_locals_idx : (HeapObject, cint) -> JSValue

externC
Array_size : JSValue -> cint     // Array -> uint64_t じゃなくてよい?

externC
Array_length : JSValue -> cint     // Array -> uint64_t じゃなくてよい?

externC
Array_body_index : (JSValue, cint) -> JSValue  // (Array, cint) -> uint64_t じゃなくてよい?

externC
Get_prop_prototype_chain : (JSValue, JSValue) -> JSValue

//externC (triggerGC, needContext, changeContext)
externC (triggerGC, needContext)
New_normal_string_object : String -> JSObject

//externC (triggerGC, needContext, changeContext)
externC (triggerGC, needContext)
New_normal_number_object : Number -> JSObject

externC
Instanceof : JSValue -> cint
/*
  C 側に 探索する関数を用意する
    JSValue p;
    get_prop(v2, gconsts.g_string_prototype, &p) == SUCCESS) {
    while (get___proto__(v1, &v1) == SUCCESS) {
      if (v1 == p) {
        return TRUE;
      }
    }
    return FALSE;
*/

externC
Get_next_propname : (JSValue, JSValue) -> JSValue
/*
  C 側に 探索する関数を用意する
  JSValue res = JS_UNDEFINED;
  while (1) {
    int r = get_next_propname(itr, &res);
    if (r != SUCCESS) {
      break;
    } else if ((val = get_prop_prototype_chain(obj, res)) != JS_UNDEFINED) {
      break;
    }
  }
  return res;
*/

externC
Set_pc_relative : cint -> void

//externC (needContext, needPC)
externC (needContext)
Lcall_stack_push : () -> void

externC (needContext)
Lcall_stack_pop : () -> cint      // cint pc を返すようにかえる

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
New_normal_function : cint -> Function

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
New_normal_iterator : JSObject -> JSObject

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
New_normal_simple_iterator : JSObject -> JSObject

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
New_normal_array_with_size : cint -> Array

//externC (needContext, triggerGC, changeContext)
externC (needContext, triggerGC)
New_frame : (HeapObject, HeapObject, cint) -> HeapObject

externC
Floor : cdouble -> cdouble

externC
Ceil : cdouble -> cdouble

externC
Half_fixnum_range : cint -> cint

//externC (triggerGC, needContext, changeContext)
externC (triggerGC, needContext)
New_normal_object : () -> JSObject

//externC (needContext, changeContext)
externC (needContext)
Set___proto___all : (JSValue, JSValue) -> void

externC (needContext)
Get_cf : () -> HeapObject

externC (needContext)
Get_lp : () -> HeapObject

//externC (needContext, changeContext)
externC (needContext)
Set_lp : HeapObject -> void

externC (needContext)
Get_ac : () -> cint

externC
Get_register : cint -> JSValue

//externC (needContext, changeContext)
externC (needContext)
Set_a : JSValue -> void

externC
Get_code : cint -> Top    // insns[d1].code を返す

externC (needContext)
Exhandler_stack_pop : () -> (cint, cint)    // 中で cint_to_number しているので，DSL で書きたいところだけど

externC (needContext)
Exhandler_stack_push : (cint, cint) -> void

externC (needContext)
Ret : () -> void    // ret 命令の中身
// /*  &stack とかが書けないので，C で書いたほうがよいのではないか
// {
//   JSValue *stack;

//   if (fp == border)
//     return 1;
//   stack = &get_stack(context, 0);
//   restore_special_registers(context, stack, fp - 4);
//   set_sp(context, fp - 5);
//   update_context();
// }
// */

externC (needContext)
Throw : () -> void
// /*   throw の中身．ret と同じ箇所がある
// {
//   Displacement disp;
//   int newpc;
//   int handler_fp;
//   exhandler_stack_pop(context, &newpc, &handler_fp);
//   while (handler_fp != fp) {
//     JSValue *stack;
//     stack = &get_stack(context, 0);
//     restore_special_registers(context, stack, fp - 4);
//     set_sp(context, fp - 5);
//     update_context();      /* TODO: optimise */
//   }
//   disp = (Displacement) (newpc - pc);
//   set_pc_relative(disp);
// }
// */

//externC (needContext, changeContext)
externC (needContext)
Set_array_prop : (JSValue, Fixnum, JSValue) -> void

//externC (needContext, changeContext)
externC (needContext)
Set_object_prop : (JSValue, Fixnum, JSValue) -> void

externC (needContext)
Get_sp : () -> cint

externC (needContext)
Set_sp : cint -> void

externC (needContext)
Set_fp : cint -> void

externC (needContext)
Set_pc : cint -> void

externC (needContext)
toString : JSValue -> String

externC (needContext)
concat : (String, String) -> String

externC
toCdouble : JSValue -> cdouble

pattern ffs v = Fixnum v || Flonum v || Special v
pattern ffss v = Fixnum v || Flonum v || Special v || String v
pattern object v = SimpleObject v || Array v || Function v || Builtin v || SimpleIterator v || Regexp v || StringObject v || NumberObject v || BooleanObject v

(vmInstruction, needContext, triggerGC, tailCall)
add : (JSValue, JSValue) -> JSValue

// 下のように人間が書くのは無理
// add : ( (Number, Number) -> Number
//       | (String, (Number | Special)) -> String
//       | ((Number | Special), String) -> String
//       | (String, String) -> String
//       | (Generic, (Number | Special | String)) -> Number | String
//       | ((Number | Special | String), Generic) -> Number | String
//       | (Generic, Generic) ->  Number | String

add (v1, v2) {
  top: match (v1, v2) {
    case (Fixnum v1 && Fixnum v2) {
      cint s = FixnumToCint(v1) + FixnumToCint(v2);
      return CintToNumber(s);
    }
    case (String v1 && ffs v2) {
      // ここでは v2 の型は一意に決まらないので ffs の LUB の型になる
      // この場合は LUB(f,f,s) = JSValue なので v2 は JSValue 型
      String s = toString(v2);
      rematch top(v1, s);  // v1:string, s:string
    }
    case (ffs v1 && String v2) {
      String s = toString(v1);
      rematch top(s, v2);  // s:string, v2:string
    }
    case (String v1 && String v2) {
      return concat(v1, v2);
    }
    case (object v1 && ffss v2) {
      JSValue u1 = toString(v1);
      rematch top(u1, v2);  // u1:string, v2:LUB(ffss \cap type(v2)@top)
    }
    case (ffss v1 && object v2) {
      JSValue u2 = toString(v2);
      rematch top(v1, u2);  // v1:LUB(ffss \cap type(v1)@top), u2:string
      // JSValue u1 = v1;
      // JSValue u2 = toString(v2);
      // rematch top(u1, u2);
    }
    case (true)
     {
      cdouble u1 = toCdouble(v1);
      cdouble u2 = toCdouble(v2);
      return CdoubleToNumber(u1 + u2);
    }
  }
}